(defpackage :tic80
  (:use :common-lisp)
  (:shadow print)
  (:export :cls :line :print :pix :spr :rect :rectb :circ :circb))
(in-package :tic80)

(defvar *TICCORE*)

;; this can probably be replaced with that macro if we can import api.h without blowing up
(ffi:clines "extern int32_t tic_api_print(void* tic, const char* text, int32_t x, int32_t y, uint8_t color, bool fixed, int32_t scale, bool alt);")
(ffi:clines "extern void tic_api_cls(void* tic, uint8_t color);")
(ffi:clines "extern uint8_t tic_api_pix(void* tic, int32_t x, int32_t y, uint8_t color, bool get);")
(ffi:clines "extern void tic_api_line(void* tic, int32_t x1, int32_t y1, int32_t x2, int32_t y2, uint8_t color);")
(ffi:clines "extern void tic_api_rect(void* tic, int32_t x, int32_t y, int32_t width, int32_t height, uint8_t color);")
(ffi:clines "extern void tic_api_rectb(void* tic, int32_t x, int32_t y, int32_t width, int32_t height, uint8_t color);")
(ffi:clines "extern void tic_api_spr(void* tic, int32_t index, int32_t x, int32_t y, int32_t w, int32_t h, uint8_t* colors, int32_t count, int32_t scale, int32_t flip, int32_t rotate);")
(ffi:clines "extern uint32_t tic_api_btn(void* tic, int32_t id);")
(ffi:clines "extern uint32_t tic_api_btnp(void* tic, int32_t id, int32_t hold, int32_t period);")
(ffi:clines "extern void tic_api_sfx(void* tic, int32_t index, int32_t note, int32_t octave, int32_t duration, int32_t channel, int32_t left, int32_t right, int32_t speed);")
(ffi:clines "extern void tic_api_map(void* tic, int32_t x, int32_t y, int32_t width, int32_t height, int32_t sx, int32_t sy, uint8_t* colors, int32_t count, int32_t scale, void* remap, void* data);")
(ffi:clines "extern uint8_t tic_api_mget(void* tic, int32_t x, int32_t y);")
(ffi:clines "extern void tic_api_mset(void* tic, int32_t x, int32_t y, uint8_t value);")
(ffi:clines "extern uint8_t tic_api_peek(void* tic, int32_t address);")
(ffi:clines "extern void tic_api_poke(void* tic, int32_t address, uint8_t value);")
(ffi:clines "extern uint32_t tic_api_peek4(void* tic, int32_t address);")
(ffi:clines "extern void tic_api_poke4(void* tic, int32_t address, uint32_t value);")
(ffi:clines "extern void tic_api_memcpy(void* tic, int32_t dst, int32_t src, int32_t size);")
(ffi:clines "extern void tic_api_memset(void* tic, int32_t dst, uint8_t val, int32_t size);")
(ffi:clines "extern void tic_api_trace(void* tic, const char* text, uint8_t color);")
(ffi:clines "extern uint32_t tic_api_pmem(void* tic, int32_t index, uint32_t value, bool get);")
(ffi:clines "extern double tic_api_time(void* tic);")
(ffi:clines "extern int32_t tic_api_tstamp(void* tic);")
(ffi:clines "extern void tic_api_exit(void* tic);")
(ffi:clines "extern int32_t tic_api_font(void* tic, const char* text, int32_t x, int32_t y, uint8_t chromakey, int32_t w, int32_t h, bool fixed, int32_t scale, bool alt);")
;;(ffi:clines "extern tic_api_mouse(void* tic);") ; this needs to return a tic_point which I can't find the def for
(ffi:clines "extern void tic_api_circ(void* tic, int32_t x, int32_t y, int32_t radius, uint8_t color);")
(ffi:clines "extern void tic_api_circb(void* tic, int32_t x, int32_t y, int32_t radius, uint8_t color);")
(ffi:clines "extern void tic_api_tri(void* tic, int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x3, int32_t y3, uint8_t color);")
(ffi:clines "extern void tic_api_textri(void* tic, float x1, float y1, float x2, float y2, float x3, float y3, float u1, float v1, float u2, float v2, float u3, float v3, bool use_map, uint8_t* colors, int32_t count);")
(ffi:clines "extern void tic_api_clip(void* tic, int32_t x, int32_t y, int32_t width, int32_t height);")
(ffi:clines "extern void tic_api_music(void* tic, int32_t track, int32_t frame, int32_t row, bool loop, bool sustain);")
(ffi:clines "extern void tic_api_sync(void* tic, uint32_t mask, int32_t bank, bool toCart);")
(ffi:clines "extern void tic_api_reset(void* tic);")
(ffi:clines "extern bool tic_api_key(void* tic, uint8_t key);")
(ffi:clines "extern bool tic_api_keyp(void* tic, uint8_t key, int32_t hold, int32_t period);")
(ffi:clines "extern bool tic_api_fget(void* tic, int32_t index, uint8_t flag);")
(ffi:clines "extern void tic_api_fset(void* tic, int32_t index, uint8_t flag, bool value);")
;; however I've got no clue how to generate these without parsing C or something

(defun wrap-colorkey (c)
  (let* ((c (if (consp c) c (list c)))
         (arr (ffi:allocate-foreign-object :byte (length c))))
    (loop for v in c for i from 0 do (setf (ffi:deref-array arr (* :byte) i) v))
    arr))

(defun print (text &key (x 0) (y 0) (color 15) (fixed nil) (scale 1) (alt nil))
  (check-type text string)
  (ffi:with-cstring (cstr text)
    (ffi:c-inline (*TICCORE* cstr x y color fixed scale alt)
                  (:int :cstring :int :int :byte :bool :int :bool)
                  :int "tic_api_print(#0, #1, #2, #3, #4, #5, #6, #7);")))

(defun cls (color)
  (ffi:c-inline (*TICCORE* color)
                (:int :byte)
                :void "tic_api_cls(#0, #1);" :one-liner t))
(defun pix (x y color get)
  (ffi:c-inline (*TICCORE* x y color get)
                (:int :int :int :byte :bool)
                :byte "tic_api_pix(#0, #1, #2, #3, #4);"))

(defun line (x1 y1 x2 y2 color)
  (ffi:c-inline (*TICCORE* x1 y1 x2 y2 color)
                (:int :int :int :int :int :byte)
                :void "tic_api_line(#0, #1, #2, #3, #4, #5);"))

(defun rect (x y w h color)
  (ffi:c-inline (*TICCORE* x y w h color)
                (:int :int :int :int :int :byte)
                :void "tic_api_rect(#0, #1, #2, #3, #4, #5);"))

(defun rectb (x y w h color)
  (ffi:c-inline (*TICCORE* x y w h color)
                (:int :int :int :int :int :byte)
                :void "tic_api_rectb(#0, #1, #2, #3, #4, #5);"))

(defun spr (index x y &key (colorkey -1) (scale 1) (flip 0) (rotate 0) (w 1) (h 1))
  (let ((ck (wrap-colorkey colorkey)))
    (ffi:c-inline (*TICCORE* index x y w h ck (length ck) scale flip rotate)
                  (:int :int :int :int :int :int (* :byte) :int :int :int :int)
                  :void "tic_api_spr(#0, #1, #2, #3, #4, #5, #6, #7, #8, #9, #A);")))

(defun ticmap (x y &key (w 30) (h 18) (sx 0) (sy 0) (colorkey -1) (scale 1) (remap nil))
  (let ((ck (wrap-colorkey colorkey))
        (data nil)) ; this is an object that you can pass to the callback fn
    (ffi:c-inline (*TICCORE* x y w h sx sy ck (length ck) scale remap data)
                  (:int :int :int :int :int :int :int (* :byte) :int :int (* :void) (* :void))
                  :void "tic_api_map(#0, #1, #2, #3, #4, #5, #6, #7, #8, #9, #A, #B);")))

(defun circ (x y r color)
  (ffi:c-inline (*TICCORE* x y r color)
                (:int :int :int :int :byte)
                :void "tic_api_circ(#0, #1, #2, #3, #4);"))

(defun circb (x y r color)
  (ffi:c-inline (*TICCORE* x y r color)
                (:int :int :int :int :byte)
                :void "tic_api_circb(#0, #1, #2, #3, #4);"))
